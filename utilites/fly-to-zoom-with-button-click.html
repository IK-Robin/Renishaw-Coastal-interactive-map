<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zoom, Pan & Fly-to-Zoom with Buttons</title>
    <style>
        body { margin:0; font-family:Arial,sans-serif; background:#f0f0f0; }
        .container { display:flex; flex-direction:column; height:100vh; }
        .controls { padding:10px; background:#ddd; display:flex; gap:10px; flex-wrap:wrap; }
        button { padding:5px 10px; cursor:pointer; }
        svg { flex:1; border:1px solid #ccc; background:#fff; touch-action:none; }
        .shape { cursor:pointer; fill:#3498db; stroke:#2980b9; stroke-width:2; }
        .shape:hover { fill:#2980b9; }
    </style>
</head>
<body>
<div class="container">
    <!-- Zoom controls -->
    <div class="controls" id="topControls">
        <button id="zoomInBtn">Zoom In</button>
        <button id="zoomOutBtn">Zoom Out</button>
        <button id="resetBtn">Reset View</button>
    </div>

    <!-- Buttons for every shape (generated by JS) -->
    <div class="controls" id="shapeButtons"></div>

    <!-- SVG map -->
    <svg id="map" viewBox="0 0 800 600">
        <rect id="bg" x="0" y="0" width="800" height="600" fill="#f9f9f9"/>
        <g id="stage">
            <!-- Sample shapes â€“ every shape has an id -->
            <rect   class="shape" id="rect1"   x="100" y="100" width="100" height="100"/>
            <circle class="shape" id="circle1" cx="300" cy="200" r="50"/>
            <rect   class="shape" id="rect2"   x="500" y="300" width="150" height="80"/>
            <path   class="shape" id="path1"   d="M50,400 L200,400 L200,500 L50,500 Z"/>
        </g>
    </svg>
</div>

<script>
    /* ---------- SHARED STATE & HELPERS ---------- */
    const transform = { x:0, y:0, scale:1 };
    let baseTransform = { x:0, y:0, scale:1 };

    const map   = document.getElementById('map');
    const stage = document.getElementById('stage');
    const shapeButtonsContainer = document.getElementById('shapeButtons');

    function applyTransform() {
        stage.setAttribute('transform',
            `translate(${transform.x},${transform.y}) scale(${transform.scale})`);
    }

    function animateTo(target, duration=280, onUpdate=null, onDone=null) {
        const start = { ...transform };
        const dt = {
            x: target.x - start.x,
            y: target.y - start.y,
            scale: target.scale - start.scale
        };
        const t0 = performance.now();

        function step(now) {
            const p = Math.min((now-t0)/duration, 1);
            const ease = p<0.5 ? 2*p*p : 1-Math.pow(-2*p+2,2)/2;

            transform.x = start.x + dt.x * ease;
            transform.y = start.y + dt.y * ease;
            transform.scale = start.scale + dt.scale * ease;

            applyTransform();
            if (onUpdate) onUpdate(ease);

            if (p<1) requestAnimationFrame(step);
            else if (onDone) onDone();
        }
        requestAnimationFrame(step);
    }

    function computeFitTransform(bb, padding=24) {
        const svgW=800, svgH=600;
        const scale = Math.min(
            svgW/(bb.width+padding*2),
            svgH/(bb.height+padding*2)
        );
        const cx = bb.x + bb.width/2;
        const cy = bb.y + bb.height/2;
        return { x:svgW/2-scale*cx, y:svgH/2-scale*cy, scale };
    }

    /* ---------- ZOOM MODULE ---------- */
    const ZoomModule = {
        init() {
            document.getElementById('zoomInBtn')
                .addEventListener('click',()=>this.zoom(1.25));
            document.getElementById('zoomOutBtn')
                .addEventListener('click',()=>this.zoom(0.8));
            document.getElementById('resetBtn')
                .addEventListener('click',this.reset.bind(this));

            map.addEventListener('wheel', e=>{
                e.preventDefault();
                const r = map.getBoundingClientRect();
                this.zoom(e.deltaY<0?1.1:0.9, e.clientX-r.left, e.clientY-r.top);
            },{passive:false});
        },
        zoom(factor, cx=400, cy=300) {
            const newScale = Math.max(0.1, Math.min(5, transform.scale*factor));
            transform.x = cx - (cx-transform.x)*(newScale/transform.scale);
            transform.y = cy - (cy-transform.y)*(newScale/transform.scale);
            transform.scale = newScale;
            applyTransform();
        },
        reset() {
            const tgt = {x:0,y:0,scale:1};
            animateTo(tgt);
            baseTransform = {...tgt};
        }
    };

    /* ---------- PAN MODULE ---------- */
    const PanModule = {
        thresh:6,
        state:{tracking:false,panning:false,id:null,startX:0,startY:0,lastX:0,lastY:0},
        justDragged:false,

        init() {
            map.addEventListener('pointerdown', this.down.bind(this));
            map.addEventListener('pointermove', this.move.bind(this));
            map.addEventListener('pointerup',    this.up.bind(this));
            map.addEventListener('pointercancel',this.up.bind(this));
        },
        down(e){
            if(!(e.target===map || e.target.id==='bg')) return;
            this.state.tracking=true; this.state.panning=false;
            this.state.id=e.pointerId;
            this.state.startX=this.state.lastX=e.clientX;
            this.state.startY=this.state.lastY=e.clientY;
            map.setPointerCapture(e.pointerId);
        },
        move(e){
            if(!this.state.tracking || e.pointerId!==this.state.id) return;
            const dx0=e.clientX-this.state.startX;
            const dy0=e.clientY-this.state.startY;
            if(!this.state.panning && Math.hypot(dx0,dy0)>=this.thresh){
                this.state.panning=true; this.justDragged=true;
            }
            if(!this.state.panning) return;
            const dx=e.clientX-this.state.lastX;
            const dy=e.clientY-this.state.lastY;
            this.state.lastX=e.clientX; this.state.lastY=e.clientY;
            transform.x+=dx; transform.y+=dy;
            applyTransform();
        },
        up(e){
            if(this.state.panning && e.pointerId===this.state.id)
                map.releasePointerCapture(e.pointerId);
            this.state={tracking:false,panning:false,id:null,startX:0,startY:0,lastX:0,lastY:0};
            if(this.justDragged) setTimeout(()=>{this.justDragged=false;},0);
        }
    };

    /* ---------- FLY-TO-ZOOM (shared) ---------- */
    function flyToShape(shapeEl) {
        if (PanModule.justDragged) return;
        const bb = shapeEl.getBBox();
        const target = computeFitTransform(bb, 24);
        animateTo(target, 300, null, ()=>{ baseTransform={...target}; });
    }

    /* ---------- SHAPE BUTTONS ---------- */
    function createShapeButtons() {
        const shapes = stage.querySelectorAll('.shape[id]');
        shapes.forEach(shape => {
            const btn = document.createElement('button');
            btn.textContent = `Zoom to ${shape.id}`;
            btn.dataset.targetId = shape.id;
            btn.addEventListener('click', () => {
                const target = document.getElementById(btn.dataset.targetId);
                if (target) flyToShape(target);
            });
            shapeButtonsContainer.appendChild(btn);
        });
    }

    /* ---------- CLICK ON SHAPE (original behaviour) ---------- */
    stage.addEventListener('click', e => {
        if (PanModule.justDragged) return;
        const shape = e.target.closest('.shape');
        if (shape) flyToShape(shape);
    });

    /* ---------- INITIALISE ---------- */
    applyTransform();
    ZoomModule.init();
    PanModule.init();
    createShapeButtons();   // <-- generates a button per id-ed shape
</script>
</body>
</html>